import glob
import subprocess
from concurrent.futures import ProcessPoolExecutor
from itertools import chain, product, zip_longest
from typing import Dict, List, Tuple

from tqdm import tqdm


def cartesian_product(parameters: Dict[str, List[str]]) -> List[Tuple[str]]:
    """
    Generate a list of commands by taking the cartesian product of the values in the input dictionary.

    Args:
        parameters (Dict): A dictionary containing the parameter names as keys and a list of values as values.

    Returns:
        List[str]: A list of commands generated by taking the cartesian product of the values in the input dictionary.
    """
    commands: List[Tuple[str]] = []
    for experiment in product(*parameters.values()):
        chained_command = chain(*zip(parameters, experiment))  #  place flag and value together
        command: Tuple[str] = tuple(filter(bool, chained_command))  # remove empty strings and None values
        commands.append(command)
    return commands

def zip_longest_repeat_shortest(parameters: Dict[str, List[str]]) -> List[Tuple[str]]:
    
    commands: List[Tuple[str]] = []
    max_len: int = max([len(v) for v in parameters.values()]) 
    for key, item in parameters.items():
        length = len(item)
        if length < max_len:
            parameters[key] = item * (len(parameters[key]) // length)
        
    for experiment in zip_longest(*parameters.values(), ):
        command = chain(*zip(parameters, experiment))  #  place flag and value together
        command: Tuple[str] = tuple(filter(bool, command))  # remove empty strings and None values
        commands.append(command)
        
    return commands

def run(command: List[str]) -> subprocess.CompletedProcess:
    """
    Runs a command and returns the completed process.

    Args:
        command (List[str]): The command to run.

    Returns:
        subprocess.CompletedProcess: The completed process.
   """
    retval = None
    try:
        retval = subprocess.run(command, capture_output=True, check=True)
    except subprocess.CalledProcessError as e:
        print(e.stderr.decode('utf-8'))
        print(e.stdout.decode('utf-8'))

    return retval

maps: List[str] = glob.glob("./map/orz*.map")  
scenarios: List[str] = glob.glob("./scenario/orz*.scen")

# Format the following as a dictionary of lists of strings
args: Dict[str, List[str]] = {
    "./build/lns": [None],
    "-m": maps,
    "-a": scenarios,
    "-o": ["test"],
    "-k": [str(x) for x in range(1, 10)],
    "-t": ["60"],
    "--initLNS": ["false"],
    "--initAlgo": ["winPP"],
    "--replanAlgo": ["winPP"],
    "--maxIterations": ["10000"],
    "--outputPaths": ["paths.txt"],
    "--planningPeriod": ["10"],
    "--planningHorizon": ["20"],
    "--screen": ["0"]
}


if __name__ == "__main__":
    experiments: List[Tuple[str]] = cartesian_product(args)
    with ProcessPoolExecutor(max_workers=2) as executor:
        result = list(tqdm(executor.map(run, experiments), total=len(experiments), desc="Running experiments"))
